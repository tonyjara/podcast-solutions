// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
  // Further reading:
  // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
  url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
  id         String    @id @default(cuid())
  active     Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime? @updatedAt
  email      String    @unique
  password   String
  role       Role      @default(user)
  isVerified Boolean   @default(false)

  user User?

  PasswordRecoveryLinks PasswordRecoveryLinks[]
}

model User {
  id           String        @id @default(cuid())
  updatedAt    DateTime?     @updatedAt
  firstName    String
  lastName     String
  image        String
  subscription Subscription?
  Preferences  Preferences?

  audios   AudioFile[]
  podcasts Podcast[]
  payment  Payment[]
  episodes Episode[]

  accountId String  @unique
  account   Account @relation(fields: [accountId], references: [id])
}

model AccountVerificationLinks {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  verificationLink String
  email            String
  hasBeenUsed      Boolean  @default(false)
}

model PasswordRecoveryLinks {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  recoveryLink String
  email        String
  hasBeenUsed  Boolean  @default(false)
  account      Account? @relation(fields: [accountId], references: [id])
  accountId    String?
}

model Preferences {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  hasSeenOnboarding Boolean  @default(false)
  selectedPodcastId String

  showTranscriptionWarning Boolean @default(true)

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Podcast {
  id          String      @id @default(cuid())
  active      Boolean     @default(false) // After edit it becomes active
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  publishedAt DateTime?
  name        String
  email       String
  author      String
  slug        String      @unique
  description String
  categories    String[]
  language    String
  imageUrl    String
  explicit    Boolean
  type        PodcastType @default(episodic)

  user     User[]
  audios   AudioFile[]
  episodes Episode[]
}

model Episode {
  id            String        @id @default(cuid())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  releaseDate   DateTime?
  title         String
  showNotes     String
  transcription String
  imageUrl      String
  explicit      Boolean
  status        EpisodeStatus @default(draft)
  seasonNumber  Int?
  episodeNumber Int?
  episodeType   EpisodeType   @default(full)

  user                User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId              String
  podcast             Podcast       @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  podcastId           String
  audioFiles          AudioFile[]
  chatMessages        EpisodeChat[]
  selectedAudioFileId String?
}

model EpisodeChat {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      String
  content   String

  episode   Episode? @relation(fields: [episodeId], references: [id])
  episodeId String?
}

model AudioFile {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  name         String
  blobName     String
  url          String
  isHostedByPS Boolean  @default(true)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  episode      Episode  @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  episodeId    String
  podcast      Podcast  @relation(fields: [podcastId], references: [id], onDelete: Cascade)
  isSelected   Boolean  @default(false)
  length       Int //file size in bytes
  duration     Int //in seconds
  type         String   @default("audio/mpeg") //mp3
  podcastId    String

  @@unique([blobName, userId])
}

//One row per user, if the user signed up after the 28th then move to the first of each month
model Subscription {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  active    Boolean

  stripeSubscriptionId String
  stripePriceIds       String[]
  stripeCustomerId     String
  payments             Payment[]
  billableActions      BillableAction[]

  user   User   @relation(fields: [userId], references: [id])
  userId String @unique // relation scalar field (used in the `@relation` attribute above)
}

// Gets created whenever a checkout session is created, needs to be validated to display to user
model Payment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payedAmount Decimal @default(0) @db.Decimal(19, 4)
  invoiceId   String?

  stripeSessionId              String    @unique
  stripeLineItems              String[]
  stripeProductId              String
  stripeCheckouCompleteEventId String?
  validatedByStripeWebhook     Boolean   @default(false)
  validatedBySuccessPage       Boolean   @default(false)
  confirmedByWebhookAt         DateTime?

  User           User             @relation(fields: [userId], references: [id])
  userId         String
  billableAction BillableAction[]
  Subscription   Subscription?    @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?
}

// Are billed monthly
model BillableAction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  currenInputTokens   Decimal @default(0) @db.Decimal(19, 4)
  previousInputTokens Decimal @default(0) @db.Decimal(19, 4)
  inputTokensAmount   Decimal @default(0) @db.Decimal(19, 4)

  currentOutputTokens  Decimal @default(0) @db.Decimal(19, 4)
  previousOutputTokens Decimal @default(0) @db.Decimal(19, 4)
  outputTokensAmount   Decimal @default(0) @db.Decimal(19, 4)

  currentTranscriptionMinutes  Decimal @default(0) @db.Decimal(19, 4)
  previousTranscriptionMinutes Decimal @default(0) @db.Decimal(19, 4)
  transcriptionMinutesAmount   Decimal @default(0) @db.Decimal(19, 4)

  actionType BillingActionType

  payment        Payment?     @relation(fields: [paymentId], references: [id])
  paymentId      String?
  Subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String
}

model FeatureFlags {
  id            String  @id @default(cuid())
  signupEnabled Boolean @default(true)
  rssEnabled    Boolean @default(true)
  maintenance   Boolean @default(false)
}

enum BillingActionType {
  planIncrement
  transcription
  chatInput
  chatOutput
}

enum MeasuredUnits {
  minutes
  hours
  seconds
}

enum Role {
  admin
  user
}

enum EpisodeStatus {
  published
  draft
  archived
}

enum PodcastType {
  episodic
  serial
}

enum EpisodeType {
  full
  trailer
  bonus
}
